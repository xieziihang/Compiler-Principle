- 堆栈虚拟机、MicroC 编译器的目标平台
  - 堆栈虚拟机状态
  - 指令集
  - Java C 实现的栈式虚拟机

- 将 MicroC 编译为 堆栈虚拟机指令



## 栈式虚拟机

Micro-C 编译目标平台为栈式虚拟机

- VM 实现简单，便于理解编译概念
- 回避底层细节
- 跨 CPU 架构
- JIT 优化
- JVM/.NET/Python 都采用了此方式



## 指令集

- 所有指令操作数在栈上
- 指令执行的结果体现为：
  - 结果栈状态变化

### 指令简介

**LDI**

- 将 栈帧上某位置的值入栈 `s, i -> s, v; v = s(i);`
- `i` 为相对栈底的偏移量，从 `0` 开始索引，如 `s(0)` 表示栈底的第一个值



**STI**

- 将值写入栈上的某个位置 `s, i, v -> s, v; s(i) <= v`
- 该指令用于赋值语句 `x: x = y + 3`



**GETBP**

- GETBP 得到当前栈帧基地址 `bp`
  - `bp+0` 对应函数 *第一个* 参数/局部变量 $v_1$
  - `bp+1` 对应参数 *第二个* $v_2$



**INCSP n**

- n > 0 增长栈 分配空间 
- n < 0 减少栈 释放空间
- 语句块内的变量声明 `{int temp; ...... } `在块入口生成 `INCSP 1`，在块出口生成 `INCSP -1`



**IFZERO / IFNZER**

- 通常用在 `EQ LT` 等语句后面
- `IFZERO a` 表示 if false 跳转到 `a` ，对应 if 语句的 `else分支`，假值跳转



**CALL m, a**

- `m` 是函数参数的个数，`a` 是函数跳转目标地址
- call 执行之后，将返回地址 `r`，上个帧栈原来 `bp` 值保存在 栈上，参数 $v_1$ ~ $v_m$ 会被拷贝到栈上
- 新 `bp` 寄存器的值会指向当前 栈帧基地址，即从函数参数开始的地址



**RET m** 

- `RET m` 与 `CALL m` 相对应，从`bp` 开始算，第 `m` 个值就是 $v_m$
- `bp+0` -> $v_1$



**TAIL m, n, a**

- `m` 尾调用函数的参数
- `n` 原函数的参数个数
- 递归调用时 `m = n`





### 虚拟机状态 寄存器

- 虚拟机的当前运行状态保存在 `寄存器 bp sp pc` 与 `指令数组p` 、`调用栈s` 中
  - `数组 p` 存放程序
  - `寄存器 pc` 程序计数器，指向下一条指令的地址
  - `调用栈 s` 堆栈、保存全局变量，局部变量，中间计算结果
  - `寄存器 sp` 堆栈指针，指向栈的顶部
  - `寄存器 bp` 栈帧基指针，保存当前栈帧开始地址

- 堆栈结构
  - 堆栈底部 —— 全局变量
  - 函数调用将在堆栈上分配新的 `栈帧`



虚拟机指令集类型定义在 `Machine.fs` 文件中

​	在 MicroC编译器主文件 `Comp.fs` 中使用该文件



